# 教材
ネクストドアのJava入門講座（YouTube）講師：菅原智先生
# Javaとは？




## 注意事項
<strong>コンパイル後に修正をした場合は再度コンパイルをすること</strong>

### データ型について
1. 基本データ型　→　整数、小数、真偽、文字、がある。入るものが整数とか文字とかそのもののこと
2. 参照型　→　文字列とか配列とか。　変数宣言する際のイメージとしては箱の中に文字列のアドレスの値（参照値）が入っているイメージ。

### データ型変換について
*　データ型は自動で変換される場合と、明示しなければならない場合がある。値の大きさが小さいものから大きいものは自動。逆はキャストで指示してあげる。


*　なぜか。<br>
ex) int i ; (３２ビットで表現できる)<br>double d ;(64ビットで表現できる)<br>d = i ;　大きい箱の中に小さい箱のものは確実に入るから自動<br>i = (int) d; ←　キャストが必要<br>

#### 参照型の型変換
* 継承関係にあるクラス同士でオブジェクトの型変換がスーパー＝サブのとき自動で行われる
* サブ＝スーパーのときキャストで明示する。
### 演算子について（優先順位順に記載)
1. インクリメント、デクリメント演算子（++,-- → +1,-1）ex) a++ →　aに１を加える　a= a+1,a+= 1
2. 四則演算子　ex) *,/,%,+,-
3. 比較演算子　ex) >,<,>=,<=,!=,==
4. かつ、または　ex) &&, ||
5. 代入、複合代入 ex) =,+=,-=,*=,/=,%=
### 構造化プログラミングとは
1. 順次進行 →　処理を順番にしていく
2. 分岐　→　条件によって違う処理結果を出す
3. 繰り返し →　指定した分処理を繰り返す 

#### switchについて
* 式（byte,short,int,char）の値によって処理が変わる場合に使う。基本的には分岐はifで書くが、場合によってはswitchを使うとよい。
#### forについて
for(式１:条件式:式２)…式１はカウンタ変数の準備をすることが多い。式２はカウンタ変数のインクリメント<br>
順番としては式１、処理、条件２、条件式の順番
## オブジェクト指向
* Javaには実行用のクラス（mainメソッド含む）と、設計図のクラスがある。
* 設計図には<strong>属性</strong>と<strong>操作</strong>が含まれる。属性→　<strong>何のデータを持っているか。</strong>　操作→　<strong>何の処理ができるか。</strong>
* 属性→プログラムの世界でいう変数のこと　　　操作→　プログラムの世界でいうメソッドのこと
* 設計図を流用すれば、データが増えても、設計図を基に実体（オブジェクト）が量産できる。→データの管理のしやすさや更新につよくなる

#### クラス
設計図クラスは`class クラス名｛ 変数の定義（データ型　変数名;）、メソッドの定義｝`で作成する

#### メソッドの定義方法
`戻り値の型　メソッド名（自分で決められる）（引数リスト）{}`
呼び出し元に返す値がある場合はreturnで指定する。なにも返さない場合は戻り値の型にvoidを記述する。
#### オブジェクトの使い方
1. 生成　`クラス名　オブジェクト名　= new クラス名();` `Student　stu1 = new Student();`イメージとしては設計図を基にからの入れ物を作る感じ。そして、オブジェクトにはこの入れ物の所在地が入っている。これをインスタンス化という。これにはデフォルト値が設定される。例えばint型なら、０。
2. 変数・メソッドを利用　`オブジェクト名.変数名;`　`オブジェクト名.メソッド名(引数);`で利用できる。例えば、`stu1.name = "佐野";`であればstu1の所在地のnameのなかに"佐野"の所在地を代入する。

コンパイルする場合はメインメソッドの入ったファイルをコンパイルする。

### 三項演算子
条件式？　式１：式２　条件がtrueなら式１を実行。falseなら式２を実行。

### do~while
do内の処理を実行してから条件式が評価される

#### オーバーロード
* クラス内に同じ名前で引数の型や数が違うメソッドを複数定義すること。
* 呼び出すメソッドは引数と名前の組み合わせで決めている。
* 設計図クラスで同じ名前を同じ処理としておけば、分かりやすくなる。名づけが楽になる。
* 実行クラス側としては、名前をたくさん覚えなくていいので使いやすい。

#### コンストラクタ
* オブジェクトの初期化のために使われる特殊なメソッドのこと
1. 名前はクラス名と同じである必要がある（大文字スタート）
2. 戻り値を持たない
3. 呼び出す側は`new クラス名（コンストラクタへの引数）`

#### カプセル化
アクセス修飾子でクラス・メンバ変数・メソッドの公開範囲を指定できる
* メンバ変数は隠ぺい（private）して、クラスとメソッドは公開（public）する設計方針を<strong>カプセル化</strong>という。
* メリットとしては代入前処理が可能　→　不正な値の入力を防ぐことができる。　プログラムの修正範囲が狭まる。

### 継承
継承とは既存のクラスを基に変数やメソッドを追加したクラスを作ること。継承関係にある親のクラスをスーパークラスと呼び、子のクラスをサブクラスという。
* メリットコーディングが楽になる。メンテナンスも楽になる。
* 継承できるクラスは１つだけ。
* コンストラクタだけは継承しない
* class Student extends Person{}
1. 機能追加
2. 共通点のまとめ
* 複数のクラスからスーパークラスを作ること。
### 抽象クラスとポリモフィズム
* 実装内容を持たないメソッドを抽象メソッドといい、<strong>abstract</strong>をつける
* 抽象メソッドをもつクラスを抽象クラスと呼び、abstractをつける。中身がないためインスタンス化はできない。

### インターフェース
定数と抽象メソッドのみ定義できる。
* クラス名の前にinterfaceをつける。データ型　定数名（大文字）　＝　値
* インターフェースを実装（implement）したクラスではすべてのメソッドの処理を定義する.
* インターフェースは複数実装できる
* 継承は枝を張る。実装は色を塗るイメージ。
* 

#### オーバーライド
サブクラスでスーパークラスのメソッドを再定義すること。（上書き）<br>オーバーロードとは別物なので注意。
##### 条件
1. 戻り値の型
2. メソッド名
3. 引数の型と数
上記がすべて同じである必要があり。
オーバーライドするとインスタンスに２つのメソッドが含まれることになる。

#### this.superによるメソッドの呼び出し
* this.~ = 自オブジェクトの～
* super.~ = スーパークラスの～
メリット。同じコードを書かなくてよい。引数の名前を考えなくてよい。
#### thisとsuperによるコンストラクタの呼び出し
* this(引数),super(引数)strong
<strong>必ずコンストラクト内の先頭に記述すること</strong>
#### Finalキーワード
クラス、メンバ変数、メソッドにつけられる修飾子。これで最後の意味
* クラス　継承できなくなる
* メンバ変数　代入ができなくなる。→　つまり定数を作れる定数名はすべて大文字
* メソッド　オーバーライドできなくなる。

### パッケージとは
パッケージは複数のクラスをまとめる仕組み。
1. パッケージ化の宣言。package (パッケージ名);パッケージ化したときは同じ名前のフォルダに入れる必要がある。
2. パッケージの利用。インポートしてパッケージ名を省略する。import A.クラス名→複数パッケージがある場合は`import pack.*`でもおけ
3. 最後にクラス書く。package　→ import　→ classの順番

### 例外
実行時に発生するエラーを例外という。例外が発生すると例外クラスのオブジェクトが自動生成される。
Throwableクラスの中にErrorクラス（システムが原因）、Exceptionクラス（プログラムが原因）がある。さらにExのなかにはRuntimeException（プログラムのどこでも発生しうるエラーのこと）がある
* throw 例外オブジェクト:例外を強制的に発生させる。
* throｗs 例外クラス:めっそどがその例外を発生することを宣言する。
### 例外処理
例外発生時に自動生成される例外オブジェクトを受け取るためにtry,catchブロックを書く。例外処理を複数書くときはサブクラス→スーパークラスの順番で書く。<br>
try{<br>
[通常の処理]<br>
｝（例外クラス　オブジェクト名）｛<br>
[例外発生時の処理]<br>
｝finally{（省略可）<br>
[後処理]<br>
}<br>

## API
### Objectクラスとは
すべてのクラスのルートとなるクラス→　すべてのクラスはObjectクラスを継承している。
### String クラス
String s1 = "Java";と書くのが正しい。これを使えば再利用が可能だから。文字列の比較にはequals()を使うこと。

## 標準入力
Scanner scan = new Scanner(System.in);
        String str1 = scan.next();
Scannerを使う。nextだと空白までしか認識しないので、行を読み込むときはnexyLineを使う。

## Mathクラス
数値処理を実行するためのメソッドがまとめられたクラス





